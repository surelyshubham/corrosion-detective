// src/utils/docxClientGenerator.ts
// Exports generateDocxFromSelectedPatches which accepts:
// metadata, selectedPatches (array of { id, meta, buffers: [{name,mime,buffer}] })
// returns Promise< { name, blob }[] >

type BufferEntry = { name: string; mime: string; buffer: ArrayBuffer };
type SelectedPatch = { id: string; meta?: any; buffers?: BufferEntry[]; shortInsight?: string };
type Metadata = { title?: string; assetId?: string; inspectionDate?: string; inspector?: string; globalStats?: any; recommendations?: string[]; globalImages?: BufferEntry[] };

const workerScript = `self.onmessage = async (ev) => {
  try {
    const msg = ev.data;
    if(msg.type !== 'GENERATE') {
      self.postMessage({ type:'error', message:'invalid message type' });
      return;
    }
    const { metadata, selectedPatches, options = {} } = msg.payload;
    // try dynamic import of docx from CDN
    let docx;
    try {
      docx = await import('https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.js');
    } catch (err) {
      self.postMessage({ type:'error', message:'Worker import failed. Please bundle docx into the worker or allow CDN imports. ' + String(err) });
      return;
    }
    const { Document, Packer, Paragraph, TextRun, HeadingLevel, ImageRun } = docx;

    // build doc
    const doc = new Document({
      creator: "Sigma Corrosion Detective",
      title: metadata.title || 'Inspection Report',
      description: "Corrosion inspection report generated by Sigma.",
    });

    // cover
    doc.addSection({ children: [
      new Paragraph({ text: metadata.title || 'Inspection Report', heading: HeadingLevel.TITLE }),
      new Paragraph({ text: 'Asset: ' + (metadata.assetId || '') }),
      new Paragraph({ text: 'Inspection date: ' + (metadata.inspectionDate || '') }),
      new Paragraph({ text: 'Inspector: ' + (metadata.inspector || '') }),
      new Paragraph({ text: '' })
    ]});

    // global stats
    const gs = metadata.globalStats || {};
    doc.addSection({ children: [
      new Paragraph({ text: 'Executive Summary', heading: HeadingLevel.HEADING_1 }),
      new Paragraph({ text: metadata.title ? ('Report: ' + metadata.title) : '' }),
      new Paragraph({ text: '' }),
      new Paragraph({ text: 'Global Statistics', heading: HeadingLevel.HEADING_1 }),
      new Paragraph({ text: 'Total patches included: ' + (selectedPatches.length || 0) }),
      new Paragraph({ text: 'Total corroded area (mÂ²): ' + (gs.totalCorrodedArea_m2 ?? '-') }),
      new Paragraph({ text: '' })
    ]});

    // global images (if provided)
    if(Array.isArray(metadata.globalImages)) {
      for (const gi of metadata.globalImages) {
        try {
          if(gi.buffer) {
            const uint = new Uint8Array(gi.buffer);
            doc.addSection({ children: [
              new Paragraph({ text: gi.name || 'Global image', heading: HeadingLevel.HEADING_2 }),
              new Paragraph({
                children: [ new ImageRun({ data: uint, transformation: { width: 480, height: 320 } }) ]
              })
            ]});
          }
        } catch(e) { /* continue */ }
      }
    }

    // per patch sections
    for (const p of selectedPatches) {
      const children = [
        new Paragraph({ text: 'Patch ' + p.id, heading: HeadingLevel.HEADING_2 }),
        new Paragraph({ text: 'Summary: ' + (p.shortInsight || '') }),
        new Paragraph({ text: 'Meta: ' + JSON.stringify(p.meta || {}) }),
      ];

      // add up to 4 images (top/side/iso/heat) if present
      if(Array.isArray(p.buffers)) {
        for (const b of p.buffers.slice(0,4)) {
          try {
            if(b.buffer) {
              const u = new Uint8Array(b.buffer);
              children.push(new Paragraph({
                children: [ new ImageRun({ data: u, transformation: { width: 360, height: 240 } }) ]
              }));
            }
          } catch(e){}
        }
      }

      doc.addSection({ children });
      // progress ping
      self.postMessage({ type:'progress', percent: Math.round(50 + (selectedPatches.indexOf(p)/selectedPatches.length)*40), message: 'Adding patch ' + p.id });
    }

    // recommendations
    if(Array.isArray(metadata.recommendations)) {
      doc.addSection({ children: [ new Paragraph({ text: 'Recommendations', heading: HeadingLevel.HEADING_1 })]});
      for (const r of metadata.recommendations) doc.addSection({ children: [ new Paragraph(r) ]});
    }

    // pack
    self.postMessage({ type:'progress', percent: 95, message: 'Packing DOCX' });
    const buffer = await Packer.toBuffer(doc); // Uint8Array / Buffer
    const ab = buffer.buffer ? buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength) : buffer;
    const fileName = (metadata.assetId || 'report') + '-' + Date.now() + '.docx';
    self.postMessage({ type:'done', files: [{ name: fileName, buffer: ab }] }, [ab]);
  } catch (err) {
    self.postMessage({ type:'error', message: String(err) });
  }
};`;

function createWorkerFromScript(script: string) {
  const blob = new Blob([script], { type: 'application/javascript' });
  const url = URL.createObjectURL(blob);
  const w = new Worker(url);
  URL.revokeObjectURL(url);
  return w;
}

/**
 * generateDocxFromSelectedPatches
 * @param metadata Metadata object (title, assetId, inspectionDate, inspector, globalStats, recommendations, globalImages[])
 *                globalImages: [{ name, buffer: ArrayBuffer }]
 * @param selectedPatches [{ id, meta, shortInsight, buffers: [{ name, mime, buffer: ArrayBuffer }] }]
 * @param onProgress callback
 */
export async function generateDocxFromSelectedPatches(metadata: Metadata, selectedPatches: SelectedPatch[], onProgress?: (p:{percent:number,message?:string})=>void) {
  return new Promise<{ name: string; blob: Blob }[]>((resolve, reject) => {
    const worker = createWorkerFromScript(workerScript);

    worker.onmessage = (ev) => {
      const d = ev.data;
      if (!d) return;
      if (d.type === 'progress') {
        onProgress?.({ percent: d.percent || 0, message: d.message });
      } else if (d.type === 'error') {
        worker.terminate();
        reject(new Error(d.message || 'Worker error'));
      } else if (d.type === 'done') {
        const files: { name: string; blob: Blob }[] = [];
        if (d.files && d.files.length > 0) {
            d.files.forEach((f: any) => {
                if (f.buffer) {
                    const blob = new Blob([f.buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                    files.push({ name: f.name || 'report.docx', blob });
                }
            });
        }
        worker.terminate();
        resolve(files);
      }
    };

    worker.onerror = (err) => {
        worker.terminate();
        reject(err);
    };

    // Build payload: transfer ArrayBuffers to worker to avoid copies
    const payload = { metadata, selectedPatches };
    const transfer: ArrayBuffer[] = [];
    
    if (metadata?.globalImages) {
      for (const gi of metadata.globalImages) {
        if (gi?.buffer instanceof ArrayBuffer) transfer.push(gi.buffer);
      }
    }
    for (const p of selectedPatches) {
      if (Array.isArray(p.buffers)) {
        for (const b of p.buffers) {
          if (b?.buffer instanceof ArrayBuffer) transfer.push(b.buffer);
        }
      }
    }

    worker.postMessage({ type: 'GENERATE', payload }, transfer);
  });
}
